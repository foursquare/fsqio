
/**
 * GENERATED CODE - DO NOT EDIT!
 * Generated by foursquare.thrift.codegen v3.0.1
 *

 */


package io.fsq.spindle.codegen.binary.test.gen

import io.fsq.spindle.codegen.binary.test.gen.java_test_programs._






object Program extends ProgramMeta {


  object Builder {
    sealed trait HasTypeRegistry

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasTypeRegistry
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Program] (private var obj: RawProgram) {
    def typeRegistry(v: io.fsq.common.thrift.descriptors.types.gen.TypeRegistry): Program.Builder[State with Builder.HasTypeRegistry] = {
      obj.typeRegistry_=(v)
      this.asInstanceOf[Program.Builder[State with Builder.HasTypeRegistry]]
    }


    def namespaces(v: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace]): Program.Builder[State] = {
      obj.namespaces_=(v)
      this
    }

    def namespaces(vOpt: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.namespaces_=(v)
        case None => obj.namespacesUnset()
      }
      this
    }

    def includes(v: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include]): Program.Builder[State] = {
      obj.includes_=(v)
      this
    }

    def includes(vOpt: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.includes_=(v)
        case None => obj.includesUnset()
      }
      this
    }

    def constants(v: scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const]): Program.Builder[State] = {
      obj.constants_=(v)
      this
    }

    def constants(vOpt: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.constants_=(v)
        case None => obj.constantsUnset()
      }
      this
    }

    def enums(v: scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum]): Program.Builder[State] = {
      obj.enums_=(v)
      this
    }

    def enums(vOpt: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.enums_=(v)
        case None => obj.enumsUnset()
      }
      this
    }

    def typedefs(v: scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef]): Program.Builder[State] = {
      obj.typedefs_=(v)
      this
    }

    def typedefs(vOpt: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.typedefs_=(v)
        case None => obj.typedefsUnset()
      }
      this
    }

    def structs(v: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct]): Program.Builder[State] = {
      obj.structs_=(v)
      this
    }

    def structs(vOpt: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.structs_=(v)
        case None => obj.structsUnset()
      }
      this
    }

    def unions(v: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union]): Program.Builder[State] = {
      obj.unions_=(v)
      this
    }

    def unions(vOpt: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.unions_=(v)
        case None => obj.unionsUnset()
      }
      this
    }

    def exceptions(v: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception]): Program.Builder[State] = {
      obj.exceptions_=(v)
      this
    }

    def exceptions(vOpt: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.exceptions_=(v)
        case None => obj.exceptionsUnset()
      }
      this
    }

    def services(v: scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service]): Program.Builder[State] = {
      obj.services_=(v)
      this
    }

    def services(vOpt: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.services_=(v)
        case None => obj.servicesUnset()
      }
      this
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasTypeRegistry): MutableProgram = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Program.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasTypeRegistry): Program = resultMutable()(ev0)
  }

  def newBuilder: Program.Builder.AllUnspecified = new Builder(Program.createRawRecord)

  implicit val companionProvider: ProgramCompanionProvider = new ProgramCompanionProvider

  implicit val __$ordering: _root_.scala.math.Ordering[Program] = {
    new _root_.scala.math.Ordering[Program] {
      override def compare(x: Program, y: Program): Int = x.compare(y)
    }
  }

  implicit val __$comparator: _root_.java.util.Comparator[Program] = {
    new _root_.java.util.Comparator[Program] {
      override def compare(x: Program, y: Program): Int = x.compare(y)
    }
  }
}

class ProgramMeta
    extends JavaProgramMeta[Program, RawProgram, ProgramMeta]
    with _root_.io.fsq.spindle.runtime.RecordProvider[Program] {
  override def recordName: String = "Program"


  // Thrift descriptors.
  val PROGRAM_SDESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Program")

  val NAMESPACES_FDESC: org.apache.thrift.protocol.TField =
    new _root_.io.fsq.spindle.common.thrift.base.EnhancedTField(
      "namespaces",
      org.apache.thrift.protocol.TType.LIST,
      1,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val INCLUDES_FDESC: org.apache.thrift.protocol.TField =
    new _root_.io.fsq.spindle.common.thrift.base.EnhancedTField(
      "includes",
      org.apache.thrift.protocol.TType.LIST,
      2,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val CONSTANTS_FDESC: org.apache.thrift.protocol.TField =
    new _root_.io.fsq.spindle.common.thrift.base.EnhancedTField(
      "constants",
      org.apache.thrift.protocol.TType.LIST,
      3,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val ENUMS_FDESC: org.apache.thrift.protocol.TField =
    new _root_.io.fsq.spindle.common.thrift.base.EnhancedTField(
      "enums",
      org.apache.thrift.protocol.TType.LIST,
      4,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val TYPEDEFS_FDESC: org.apache.thrift.protocol.TField =
    new _root_.io.fsq.spindle.common.thrift.base.EnhancedTField(
      "typedefs",
      org.apache.thrift.protocol.TType.LIST,
      5,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val STRUCTS_FDESC: org.apache.thrift.protocol.TField =
    new _root_.io.fsq.spindle.common.thrift.base.EnhancedTField(
      "structs",
      org.apache.thrift.protocol.TType.LIST,
      6,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val UNIONS_FDESC: org.apache.thrift.protocol.TField =
    new _root_.io.fsq.spindle.common.thrift.base.EnhancedTField(
      "unions",
      org.apache.thrift.protocol.TType.LIST,
      7,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val EXCEPTIONS_FDESC: org.apache.thrift.protocol.TField =
    new _root_.io.fsq.spindle.common.thrift.base.EnhancedTField(
      "exceptions",
      org.apache.thrift.protocol.TType.LIST,
      8,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val SERVICES_FDESC: org.apache.thrift.protocol.TField =
    new _root_.io.fsq.spindle.common.thrift.base.EnhancedTField(
      "services",
      org.apache.thrift.protocol.TType.LIST,
      9,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val TYPEREGISTRY_FDESC: org.apache.thrift.protocol.TField =
    new _root_.io.fsq.spindle.common.thrift.base.EnhancedTField(
      "typeRegistry",
      org.apache.thrift.protocol.TType.STRUCT,
      98,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "namespaces" -> NAMESPACES_FDESC,
    "includes" -> INCLUDES_FDESC,
    "constants" -> CONSTANTS_FDESC,
    "enums" -> ENUMS_FDESC,
    "typedefs" -> TYPEDEFS_FDESC,
    "structs" -> STRUCTS_FDESC,
    "unions" -> UNIONS_FDESC,
    "exceptions" -> EXCEPTIONS_FDESC,
    "services" -> SERVICES_FDESC,
    "typeRegistry" -> TYPEREGISTRY_FDESC
  )

  object _Fields {
    case object namespaces extends _Fields(1, "namespaces")
    case object includes extends _Fields(2, "includes")
    case object constants extends _Fields(3, "constants")
    case object enums extends _Fields(4, "enums")
    case object typedefs extends _Fields(5, "typedefs")
    case object structs extends _Fields(6, "structs")
    case object unions extends _Fields(7, "unions")
    case object exceptions extends _Fields(8, "exceptions")
    case object services extends _Fields(9, "services")
    case object typeRegistry extends _Fields(98, "typeRegistry")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.namespaces,
    2.toShort -> _Fields.includes,
    3.toShort -> _Fields.constants,
    4.toShort -> _Fields.enums,
    5.toShort -> _Fields.typedefs,
    6.toShort -> _Fields.structs,
    7.toShort -> _Fields.unions,
    8.toShort -> _Fields.exceptions,
    9.toShort -> _Fields.services,
    98.toShort -> _Fields.typeRegistry
  )

  override def createUntypedRawRecord: _root_.io.fsq.spindle.runtime.UntypedRecord = createRawRecord
  override def createRecord: Program = createRawRecord
  override def createRawRecord: RawProgram = new RawProgram

  override def untypedIfInstanceFrom(x: AnyRef): Option[_root_.io.fsq.spindle.runtime.UntypedRecord] = ifInstanceFrom(x)
  override def ifInstanceFrom(x: AnyRef): Option[Program] = {
    if (x.isInstanceOf[Program]) Some(x.asInstanceOf[Program]) else None
  }

  override val annotations: _root_.io.fsq.spindle.runtime.Annotations =

    new _root_.io.fsq.spindle.runtime.Annotations(scala.collection.immutable.Vector(
      ("generate_proxy", "true")
    ))

  // Spindle Descriptors.


  val namespaces =

    new _root_.io.fsq.spindle.runtime.OptionalFieldDescriptor[scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace], Program, ProgramMeta](
      name = "namespaces",
      longName = "namespaces",
      id = 1,
      annotations = Map(),
      owner = this,
      manifest = manifest[scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace]]
    ) {
      override def unsetterRaw(r: _root_.io.fsq.spindle.runtime.MutableRecord[Program]): Unit = { r.asInstanceOf[RawProgram].namespacesUnset() }
      override def getter(r: Program): Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace]] = r.namespacesOption()
      override def setterRaw(r: _root_.io.fsq.spindle.runtime.MutableRecord[Program], v: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace]): Unit = { r.asInstanceOf[RawProgram].namespaces_=(v) }

    }

  val includes =

    new _root_.io.fsq.spindle.runtime.OptionalFieldDescriptor[scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include], Program, ProgramMeta](
      name = "includes",
      longName = "includes",
      id = 2,
      annotations = Map(),
      owner = this,
      manifest = manifest[scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include]]
    ) {
      override def unsetterRaw(r: _root_.io.fsq.spindle.runtime.MutableRecord[Program]): Unit = { r.asInstanceOf[RawProgram].includesUnset() }
      override def getter(r: Program): Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include]] = r.includesOption()
      override def setterRaw(r: _root_.io.fsq.spindle.runtime.MutableRecord[Program], v: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include]): Unit = { r.asInstanceOf[RawProgram].includes_=(v) }

    }

  val constants =

    new _root_.io.fsq.spindle.runtime.OptionalFieldDescriptor[scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const], Program, ProgramMeta](
      name = "constants",
      longName = "constants",
      id = 3,
      annotations = Map(),
      owner = this,
      manifest = manifest[scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const]]
    ) {
      override def unsetterRaw(r: _root_.io.fsq.spindle.runtime.MutableRecord[Program]): Unit = { r.asInstanceOf[RawProgram].constantsUnset() }
      override def getter(r: Program): Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const]] = r.constantsOption()
      override def setterRaw(r: _root_.io.fsq.spindle.runtime.MutableRecord[Program], v: scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const]): Unit = { r.asInstanceOf[RawProgram].constants_=(v) }

    }

  val enums =

    new _root_.io.fsq.spindle.runtime.OptionalFieldDescriptor[scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum], Program, ProgramMeta](
      name = "enums",
      longName = "enums",
      id = 4,
      annotations = Map(),
      owner = this,
      manifest = manifest[scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum]]
    ) {
      override def unsetterRaw(r: _root_.io.fsq.spindle.runtime.MutableRecord[Program]): Unit = { r.asInstanceOf[RawProgram].enumsUnset() }
      override def getter(r: Program): Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum]] = r.enumsOption()
      override def setterRaw(r: _root_.io.fsq.spindle.runtime.MutableRecord[Program], v: scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum]): Unit = { r.asInstanceOf[RawProgram].enums_=(v) }

    }

  val typedefs =

    new _root_.io.fsq.spindle.runtime.OptionalFieldDescriptor[scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef], Program, ProgramMeta](
      name = "typedefs",
      longName = "typedefs",
      id = 5,
      annotations = Map(),
      owner = this,
      manifest = manifest[scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef]]
    ) {
      override def unsetterRaw(r: _root_.io.fsq.spindle.runtime.MutableRecord[Program]): Unit = { r.asInstanceOf[RawProgram].typedefsUnset() }
      override def getter(r: Program): Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef]] = r.typedefsOption()
      override def setterRaw(r: _root_.io.fsq.spindle.runtime.MutableRecord[Program], v: scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef]): Unit = { r.asInstanceOf[RawProgram].typedefs_=(v) }

    }

  val structs =

    new _root_.io.fsq.spindle.runtime.OptionalFieldDescriptor[scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct], Program, ProgramMeta](
      name = "structs",
      longName = "structs",
      id = 6,
      annotations = Map(),
      owner = this,
      manifest = manifest[scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct]]
    ) {
      override def unsetterRaw(r: _root_.io.fsq.spindle.runtime.MutableRecord[Program]): Unit = { r.asInstanceOf[RawProgram].structsUnset() }
      override def getter(r: Program): Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct]] = r.structsOption()
      override def setterRaw(r: _root_.io.fsq.spindle.runtime.MutableRecord[Program], v: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct]): Unit = { r.asInstanceOf[RawProgram].structs_=(v) }

    }

  val unions =

    new _root_.io.fsq.spindle.runtime.OptionalFieldDescriptor[scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union], Program, ProgramMeta](
      name = "unions",
      longName = "unions",
      id = 7,
      annotations = Map(),
      owner = this,
      manifest = manifest[scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union]]
    ) {
      override def unsetterRaw(r: _root_.io.fsq.spindle.runtime.MutableRecord[Program]): Unit = { r.asInstanceOf[RawProgram].unionsUnset() }
      override def getter(r: Program): Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union]] = r.unionsOption()
      override def setterRaw(r: _root_.io.fsq.spindle.runtime.MutableRecord[Program], v: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union]): Unit = { r.asInstanceOf[RawProgram].unions_=(v) }

    }

  val exceptions =

    new _root_.io.fsq.spindle.runtime.OptionalFieldDescriptor[scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception], Program, ProgramMeta](
      name = "exceptions",
      longName = "exceptions",
      id = 8,
      annotations = Map(),
      owner = this,
      manifest = manifest[scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception]]
    ) {
      override def unsetterRaw(r: _root_.io.fsq.spindle.runtime.MutableRecord[Program]): Unit = { r.asInstanceOf[RawProgram].exceptionsUnset() }
      override def getter(r: Program): Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception]] = r.exceptionsOption()
      override def setterRaw(r: _root_.io.fsq.spindle.runtime.MutableRecord[Program], v: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception]): Unit = { r.asInstanceOf[RawProgram].exceptions_=(v) }

    }

  val services =

    new _root_.io.fsq.spindle.runtime.OptionalFieldDescriptor[scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service], Program, ProgramMeta](
      name = "services",
      longName = "services",
      id = 9,
      annotations = Map(),
      owner = this,
      manifest = manifest[scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service]]
    ) {
      override def unsetterRaw(r: _root_.io.fsq.spindle.runtime.MutableRecord[Program]): Unit = { r.asInstanceOf[RawProgram].servicesUnset() }
      override def getter(r: Program): Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service]] = r.servicesOption()
      override def setterRaw(r: _root_.io.fsq.spindle.runtime.MutableRecord[Program], v: scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service]): Unit = { r.asInstanceOf[RawProgram].services_=(v) }

    }

  val typeRegistry =
    new _root_.io.fsq.spindle.runtime.StructFieldDescriptor[Program, ProgramMeta, io.fsq.common.thrift.descriptors.types.gen.TypeRegistry, io.fsq.common.thrift.descriptors.types.gen.TypeRegistryMeta](
      name = "typeRegistry",
      longName = "typeRegistry",
      id = 98,
      annotations = Map(),
      owner = this,
      structMeta = io.fsq.common.thrift.descriptors.types.gen.TypeRegistry,
      manifest = manifest[io.fsq.common.thrift.descriptors.types.gen.TypeRegistry]
    ) {
      override def unsetterRaw(r: _root_.io.fsq.spindle.runtime.MutableRecord[Program]): Unit = { r.asInstanceOf[RawProgram].typeRegistryUnset() }
      override def getter(r: Program): Option[io.fsq.common.thrift.descriptors.types.gen.TypeRegistry] = r.typeRegistryOption()
      override def setterRaw(r: _root_.io.fsq.spindle.runtime.MutableRecord[Program], v: io.fsq.common.thrift.descriptors.types.gen.TypeRegistry): Unit = { r.asInstanceOf[RawProgram].typeRegistry_=(v) }

    }

  override def untypedFields: Seq[_root_.io.fsq.spindle.runtime.UntypedFieldDescriptor] = fields
  override val fields: Seq[_root_.io.fsq.spindle.runtime.FieldDescriptor[_, Program, ProgramMeta]] =
    Vector[_root_.io.fsq.spindle.runtime.FieldDescriptor[_, Program, ProgramMeta]](
      namespaces,
      includes,
      constants,
      enums,
      typedefs,
      structs,
      unions,
      exceptions,
      services,
      typeRegistry
    )


  def apply(
      namespaces: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace],
      includes: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include],
      constants: scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const],
      enums: scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum],
      typedefs: scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef],
      structs: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct],
      unions: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union],
      exceptions: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception],
      services: scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service],
      typeRegistry: io.fsq.common.thrift.descriptors.types.gen.TypeRegistry
  ): Program = {
    val ret = this.createRawRecord
    ret.namespaces_=(namespaces)
    ret.includes_=(includes)
    ret.constants_=(constants)
    ret.enums_=(enums)
    ret.typedefs_=(typedefs)
    ret.structs_=(structs)
    ret.unions_=(unions)
    ret.exceptions_=(exceptions)
    ret.services_=(services)
    ret.typeRegistry_=(typeRegistry)
    ret
  }
}

class ProgramCompanionProvider extends _root_.io.fsq.spindle.runtime.CompanionProvider[Program] {
  type CompanionT = ProgramMeta
  override def provide: ProgramMeta = Program
}


trait Program
    extends JavaProgram[io.fsq.common.thrift.descriptors.constants.gen.Const, io.fsq.common.thrift.descriptors.enums.gen.Enum, io.fsq.common.thrift.descriptors.headers.gen.Include, io.fsq.common.thrift.descriptors.headers.gen.Namespace, io.fsq.common.thrift.descriptors.services.gen.Service, io.fsq.common.thrift.descriptors.structs.gen.Exception, io.fsq.common.thrift.descriptors.structs.gen.Struct, io.fsq.common.thrift.descriptors.structs.gen.Union, io.fsq.common.thrift.descriptors.types.gen.TypeRegistry, io.fsq.common.thrift.descriptors.types.gen.Typedef,
      Program, RawProgram, ProgramMeta
    ]
    with _root_.scala.math.Ordered[Program]
    with org.apache.thrift.TBase[Program, Program._Fields] {

  override def meta: ProgramMeta

  override def compare(that: Program): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.namespacesIsSet.compareTo(that.namespacesIsSet)
      cmp != 0 }) cmp
    else if (this.namespacesIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scala.collection.JavaConverters.seqAsJavaListConverter(this.namespaces).asJava, scala.collection.JavaConverters.seqAsJavaListConverter(that.namespaces).asJava)

      cmp != 0 }) cmp
    else if ({
      cmp = this.includesIsSet.compareTo(that.includesIsSet)
      cmp != 0 }) cmp
    else if (this.includesIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scala.collection.JavaConverters.seqAsJavaListConverter(this.includes).asJava, scala.collection.JavaConverters.seqAsJavaListConverter(that.includes).asJava)

      cmp != 0 }) cmp
    else if ({
      cmp = this.constantsIsSet.compareTo(that.constantsIsSet)
      cmp != 0 }) cmp
    else if (this.constantsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scala.collection.JavaConverters.seqAsJavaListConverter(this.constants).asJava, scala.collection.JavaConverters.seqAsJavaListConverter(that.constants).asJava)

      cmp != 0 }) cmp
    else if ({
      cmp = this.enumsIsSet.compareTo(that.enumsIsSet)
      cmp != 0 }) cmp
    else if (this.enumsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scala.collection.JavaConverters.seqAsJavaListConverter(this.enums).asJava, scala.collection.JavaConverters.seqAsJavaListConverter(that.enums).asJava)

      cmp != 0 }) cmp
    else if ({
      cmp = this.typedefsIsSet.compareTo(that.typedefsIsSet)
      cmp != 0 }) cmp
    else if (this.typedefsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scala.collection.JavaConverters.seqAsJavaListConverter(this.typedefs).asJava, scala.collection.JavaConverters.seqAsJavaListConverter(that.typedefs).asJava)

      cmp != 0 }) cmp
    else if ({
      cmp = this.structsIsSet.compareTo(that.structsIsSet)
      cmp != 0 }) cmp
    else if (this.structsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scala.collection.JavaConverters.seqAsJavaListConverter(this.structs).asJava, scala.collection.JavaConverters.seqAsJavaListConverter(that.structs).asJava)

      cmp != 0 }) cmp
    else if ({
      cmp = this.unionsIsSet.compareTo(that.unionsIsSet)
      cmp != 0 }) cmp
    else if (this.unionsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scala.collection.JavaConverters.seqAsJavaListConverter(this.unions).asJava, scala.collection.JavaConverters.seqAsJavaListConverter(that.unions).asJava)

      cmp != 0 }) cmp
    else if ({
      cmp = this.exceptionsIsSet.compareTo(that.exceptionsIsSet)
      cmp != 0 }) cmp
    else if (this.exceptionsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scala.collection.JavaConverters.seqAsJavaListConverter(this.exceptions).asJava, scala.collection.JavaConverters.seqAsJavaListConverter(that.exceptions).asJava)

      cmp != 0 }) cmp
    else if ({
      cmp = this.servicesIsSet.compareTo(that.servicesIsSet)
      cmp != 0 }) cmp
    else if (this.servicesIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scala.collection.JavaConverters.seqAsJavaListConverter(this.services).asJava, scala.collection.JavaConverters.seqAsJavaListConverter(that.services).asJava)

      cmp != 0 }) cmp
    else if ({
      cmp = this.typeRegistryIsSet.compareTo(that.typeRegistryIsSet)
      cmp != 0 }) cmp
    else if (this.typeRegistryIsSet && {
      cmp = this.typeRegistryOrNull.compareTo(that.typeRegistryOrNull)

      cmp != 0 }) cmp
    else 0
  }
  override def <(that: Program): Boolean = { this.compare(that) < 0 }
  override def >(that: Program): Boolean = { this.compare(that) > 0 }
  override def <=(that: Program): Boolean = { this.compare(that) <= 0 }
  override def >=(that: Program): Boolean = { this.compare(that) >= 0 }
  override def compareTo(that: Program): Int = compare(that)

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Program

  def copy(
      namespaces: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace] = namespacesOrNull,
      includes: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include] = includesOrNull,
      constants: scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const] = constantsOrNull,
      enums: scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum] = enumsOrNull,
      typedefs: scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef] = typedefsOrNull,
      structs: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct] = structsOrNull,
      unions: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union] = unionsOrNull,
      exceptions: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception] = exceptionsOrNull,
      services: scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service] = servicesOrNull,
      typeRegistry: io.fsq.common.thrift.descriptors.types.gen.TypeRegistry = typeRegistryOrNull
  ): Program

  def mutableCopy(): MutableProgram = {
    val ret = Program.createRawRecord

    if (namespacesIsSet) ret.namespaces_=(namespacesOrNull)

    if (includesIsSet) ret.includes_=(includesOrNull)

    if (constantsIsSet) ret.constants_=(constantsOrNull)

    if (enumsIsSet) ret.enums_=(enumsOrNull)

    if (typedefsIsSet) ret.typedefs_=(typedefsOrNull)

    if (structsIsSet) ret.structs_=(structsOrNull)

    if (unionsIsSet) ret.unions_=(unionsOrNull)

    if (exceptionsIsSet) ret.exceptions_=(exceptionsOrNull)

    if (servicesIsSet) ret.services_=(servicesOrNull)

    if (typeRegistryIsSet) ret.typeRegistry_=(typeRegistryOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MutableProgram

  def toBuilder(): Program.Builder.AllSpecified = {
    val ret = new Program.Builder(Program.createRawRecord)

    if (namespacesIsSet) ret.namespaces(namespacesOrNull)

    if (includesIsSet) ret.includes(includesOrNull)

    if (constantsIsSet) ret.constants(constantsOrNull)

    if (enumsIsSet) ret.enums(enumsOrNull)

    if (typedefsIsSet) ret.typedefs(typedefsOrNull)

    if (structsIsSet) ret.structs(structsOrNull)

    if (unionsIsSet) ret.unions(unionsOrNull)

    if (exceptionsIsSet) ret.exceptions(exceptionsOrNull)

    if (servicesIsSet) ret.services(servicesOrNull)

    if (typeRegistryIsSet) ret.typeRegistry(typeRegistryOrNull)
    ret
  }

  def mergeCopy(that: Program): Program

}

trait MutableProgram extends Program
    with JavaProgramMutable[io.fsq.common.thrift.descriptors.constants.gen.Const, io.fsq.common.thrift.descriptors.enums.gen.Enum, io.fsq.common.thrift.descriptors.headers.gen.Include, io.fsq.common.thrift.descriptors.headers.gen.Namespace, io.fsq.common.thrift.descriptors.services.gen.Service, io.fsq.common.thrift.descriptors.structs.gen.Exception, io.fsq.common.thrift.descriptors.structs.gen.Struct, io.fsq.common.thrift.descriptors.structs.gen.Union, io.fsq.common.thrift.descriptors.types.gen.TypeRegistry, io.fsq.common.thrift.descriptors.types.gen.Typedef,
      Program, RawProgram, ProgramMeta
    ] {
  def namespaces_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace]): Unit
  def namespacesUnset(): Unit
  def includes_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include]): Unit
  def includesUnset(): Unit
  def constants_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const]): Unit
  def constantsUnset(): Unit
  def enums_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum]): Unit
  def enumsUnset(): Unit
  def typedefs_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef]): Unit
  def typedefsUnset(): Unit
  def structs_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct]): Unit
  def structsUnset(): Unit
  def unions_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union]): Unit
  def unionsUnset(): Unit
  def exceptions_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception]): Unit
  def exceptionsUnset(): Unit
  def services_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service]): Unit
  def servicesUnset(): Unit
  def typeRegistry_=(x: io.fsq.common.thrift.descriptors.types.gen.TypeRegistry): Unit
  def typeRegistryUnset(): Unit

  def merge(that: Program): Unit

  def copy(
      namespaces: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace] = namespacesOrNull,
      includes: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include] = includesOrNull,
      constants: scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const] = constantsOrNull,
      enums: scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum] = enumsOrNull,
      typedefs: scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef] = typedefsOrNull,
      structs: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct] = structsOrNull,
      unions: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union] = unionsOrNull,
      exceptions: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception] = exceptionsOrNull,
      services: scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service] = servicesOrNull,
      typeRegistry: io.fsq.common.thrift.descriptors.types.gen.TypeRegistry = typeRegistryOrNull
  ): MutableProgram

  override def mutable: MutableProgram = this
}


trait ProgramProxy extends Program {
  protected def underlying: Program

  override def meta = underlying.meta

// field/proxy_container.ssp
  override def namespaces: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace] = underlying.namespaces
  override def namespacesOption: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace]] = underlying.namespacesOption
  override def namespacesOrDefault: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace] = underlying.namespacesOrDefault
  override def namespacesOrNull: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace] = underlying.namespacesOrNull
  override def namespacesOrThrow: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace] = underlying.namespacesOrThrow
  override def namespacesIsSet: Boolean = underlying.namespacesIsSet
// field/proxy_container.ssp
  override def includes: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include] = underlying.includes
  override def includesOption: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include]] = underlying.includesOption
  override def includesOrDefault: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include] = underlying.includesOrDefault
  override def includesOrNull: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include] = underlying.includesOrNull
  override def includesOrThrow: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include] = underlying.includesOrThrow
  override def includesIsSet: Boolean = underlying.includesIsSet
// field/proxy_container.ssp
  override def constants: scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const] = underlying.constants
  override def constantsOption: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const]] = underlying.constantsOption
  override def constantsOrDefault: scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const] = underlying.constantsOrDefault
  override def constantsOrNull: scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const] = underlying.constantsOrNull
  override def constantsOrThrow: scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const] = underlying.constantsOrThrow
  override def constantsIsSet: Boolean = underlying.constantsIsSet
// field/proxy_container.ssp
  override def enums: scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum] = underlying.enums
  override def enumsOption: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum]] = underlying.enumsOption
  override def enumsOrDefault: scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum] = underlying.enumsOrDefault
  override def enumsOrNull: scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum] = underlying.enumsOrNull
  override def enumsOrThrow: scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum] = underlying.enumsOrThrow
  override def enumsIsSet: Boolean = underlying.enumsIsSet
// field/proxy_container.ssp
  override def typedefs: scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef] = underlying.typedefs
  override def typedefsOption: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef]] = underlying.typedefsOption
  override def typedefsOrDefault: scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef] = underlying.typedefsOrDefault
  override def typedefsOrNull: scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef] = underlying.typedefsOrNull
  override def typedefsOrThrow: scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef] = underlying.typedefsOrThrow
  override def typedefsIsSet: Boolean = underlying.typedefsIsSet
// field/proxy_container.ssp
  override def structs: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct] = underlying.structs
  override def structsOption: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct]] = underlying.structsOption
  override def structsOrDefault: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct] = underlying.structsOrDefault
  override def structsOrNull: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct] = underlying.structsOrNull
  override def structsOrThrow: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct] = underlying.structsOrThrow
  override def structsIsSet: Boolean = underlying.structsIsSet
// field/proxy_container.ssp
  override def unions: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union] = underlying.unions
  override def unionsOption: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union]] = underlying.unionsOption
  override def unionsOrDefault: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union] = underlying.unionsOrDefault
  override def unionsOrNull: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union] = underlying.unionsOrNull
  override def unionsOrThrow: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union] = underlying.unionsOrThrow
  override def unionsIsSet: Boolean = underlying.unionsIsSet
// field/proxy_container.ssp
  override def exceptions: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception] = underlying.exceptions
  override def exceptionsOption: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception]] = underlying.exceptionsOption
  override def exceptionsOrDefault: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception] = underlying.exceptionsOrDefault
  override def exceptionsOrNull: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception] = underlying.exceptionsOrNull
  override def exceptionsOrThrow: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception] = underlying.exceptionsOrThrow
  override def exceptionsIsSet: Boolean = underlying.exceptionsIsSet
// field/proxy_container.ssp
  override def services: scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service] = underlying.services
  override def servicesOption: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service]] = underlying.servicesOption
  override def servicesOrDefault: scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service] = underlying.servicesOrDefault
  override def servicesOrNull: scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service] = underlying.servicesOrNull
  override def servicesOrThrow: scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service] = underlying.servicesOrThrow
  override def servicesIsSet: Boolean = underlying.servicesIsSet
// field/proxy_ref.ssp

  override def typeRegistry: io.fsq.common.thrift.descriptors.types.gen.TypeRegistry = underlying.typeRegistry
  override def typeRegistryOption: Option[io.fsq.common.thrift.descriptors.types.gen.TypeRegistry] = underlying.typeRegistryOption
  override def typeRegistryOrNull: io.fsq.common.thrift.descriptors.types.gen.TypeRegistry = underlying.typeRegistryOrNull
  override def typeRegistryOrThrow: io.fsq.common.thrift.descriptors.types.gen.TypeRegistry = underlying.typeRegistryOrThrow
  override def typeRegistryIsSet: Boolean = underlying.typeRegistryIsSet

  override def compare(that: Program): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      namespaces: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace] = namespacesOrNull,
      includes: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include] = includesOrNull,
      constants: scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const] = constantsOrNull,
      enums: scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum] = enumsOrNull,
      typedefs: scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef] = typedefsOrNull,
      structs: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct] = structsOrNull,
      unions: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union] = unionsOrNull,
      exceptions: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception] = exceptionsOrNull,
      services: scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service] = servicesOrNull,
      typeRegistry: io.fsq.common.thrift.descriptors.types.gen.TypeRegistry = typeRegistryOrNull
  ): Program = underlying.copy(
    namespaces = namespaces,
    includes = includes,
    constants = constants,
    enums = enums,
    typedefs = typedefs,
    structs = structs,
    unions = unions,
    exceptions = exceptions,
    services = services,
    typeRegistry = typeRegistry
  )

  override def mutableCopy(): MutableProgram = underlying.mutableCopy()

  override def mergeCopy(that: Program): Program = underlying.mergeCopy(that)

  override def mutable: MutableProgram = underlying.mutable

  override def deepCopy(): Program = underlying.deepCopy()

  override def fieldForId(id: Int): Program._Fields = underlying.fieldForId(id)
  override def isSet(field: Program._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Program._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Program._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}
trait MutableProgramProxy extends MutableProgram with ProgramProxy {
  protected def underlying: MutableProgram

  override def namespaces_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace]): Unit = { underlying.namespaces_=(x) }
  override def namespacesUnset(): Unit = { underlying.namespacesUnset() }
  override def includes_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include]): Unit = { underlying.includes_=(x) }
  override def includesUnset(): Unit = { underlying.includesUnset() }
  override def constants_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const]): Unit = { underlying.constants_=(x) }
  override def constantsUnset(): Unit = { underlying.constantsUnset() }
  override def enums_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum]): Unit = { underlying.enums_=(x) }
  override def enumsUnset(): Unit = { underlying.enumsUnset() }
  override def typedefs_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef]): Unit = { underlying.typedefs_=(x) }
  override def typedefsUnset(): Unit = { underlying.typedefsUnset() }
  override def structs_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct]): Unit = { underlying.structs_=(x) }
  override def structsUnset(): Unit = { underlying.structsUnset() }
  override def unions_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union]): Unit = { underlying.unions_=(x) }
  override def unionsUnset(): Unit = { underlying.unionsUnset() }
  override def exceptions_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception]): Unit = { underlying.exceptions_=(x) }
  override def exceptionsUnset(): Unit = { underlying.exceptionsUnset() }
  override def services_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service]): Unit = { underlying.services_=(x) }
  override def servicesUnset(): Unit = { underlying.servicesUnset() }
  override def typeRegistry_=(x: io.fsq.common.thrift.descriptors.types.gen.TypeRegistry): Unit = { underlying.typeRegistry_=(x) }
  override def typeRegistryUnset(): Unit = { underlying.typeRegistryUnset() }

  override def copy(
      namespaces: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace] = namespacesOrNull,
      includes: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include] = includesOrNull,
      constants: scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const] = constantsOrNull,
      enums: scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum] = enumsOrNull,
      typedefs: scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef] = typedefsOrNull,
      structs: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct] = structsOrNull,
      unions: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union] = unionsOrNull,
      exceptions: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception] = exceptionsOrNull,
      services: scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service] = servicesOrNull,
      typeRegistry: io.fsq.common.thrift.descriptors.types.gen.TypeRegistry = typeRegistryOrNull
  ): MutableProgram = underlying.copy(
    namespaces = namespaces,
    includes = includes,
    constants = constants,
    enums = enums,
    typedefs = typedefs,
    structs = structs,
    unions = unions,
    exceptions = exceptions,
    services = services,
    typeRegistry = typeRegistry
  )

  override def merge(that: Program): Unit = underlying.merge(that)
}


final class RawProgram extends JavaProgramRaw[io.fsq.common.thrift.descriptors.constants.gen.Const, io.fsq.common.thrift.descriptors.enums.gen.Enum, io.fsq.common.thrift.descriptors.headers.gen.Include, io.fsq.common.thrift.descriptors.headers.gen.Namespace, io.fsq.common.thrift.descriptors.services.gen.Service, io.fsq.common.thrift.descriptors.structs.gen.Exception, io.fsq.common.thrift.descriptors.structs.gen.Struct, io.fsq.common.thrift.descriptors.structs.gen.Union, io.fsq.common.thrift.descriptors.types.gen.TypeRegistry, io.fsq.common.thrift.descriptors.types.gen.Typedef,
      Program, RawProgram, ProgramMeta
    ]
    with MutableProgram {
  override def meta: ProgramMeta = Program

  // fields
  // Field #1 - namespaces
  private[this] var _namespaces: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace] = null  // Underlying type: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace]
  override def namespaces: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace] = namespacesOrDefault
  override def namespaces_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace]): Unit = { _namespaces = x }
  override def namespacesOption: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace]] = if (namespacesIsSet) Some(_namespaces) else None
  override def namespacesOrDefault: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace] = if (namespacesIsSet) _namespaces else scala.collection.immutable.Vector.empty
  override def namespacesOrNull: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace] = _namespaces
  override def namespacesOrThrow: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace] = if (namespacesIsSet) _namespaces else throw new java.lang.NullPointerException("field namespaces of Program missing")
  override def namespacesIsSet: Boolean = _namespaces != null
  override def namespacesUnset(): Unit = { _namespaces = null }
  // Field #2 - includes
  private[this] var _includes: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include] = null  // Underlying type: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include]
  override def includes: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include] = includesOrDefault
  override def includes_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include]): Unit = { _includes = x }
  override def includesOption: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include]] = if (includesIsSet) Some(_includes) else None
  override def includesOrDefault: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include] = if (includesIsSet) _includes else scala.collection.immutable.Vector.empty
  override def includesOrNull: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include] = _includes
  override def includesOrThrow: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include] = if (includesIsSet) _includes else throw new java.lang.NullPointerException("field includes of Program missing")
  override def includesIsSet: Boolean = _includes != null
  override def includesUnset(): Unit = { _includes = null }
  // Field #3 - constants
  private[this] var _constants: scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const] = null  // Underlying type: scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const]
  override def constants: scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const] = constantsOrDefault
  override def constants_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const]): Unit = { _constants = x }
  override def constantsOption: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const]] = if (constantsIsSet) Some(_constants) else None
  override def constantsOrDefault: scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const] = if (constantsIsSet) _constants else scala.collection.immutable.Vector.empty
  override def constantsOrNull: scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const] = _constants
  override def constantsOrThrow: scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const] = if (constantsIsSet) _constants else throw new java.lang.NullPointerException("field constants of Program missing")
  override def constantsIsSet: Boolean = _constants != null
  override def constantsUnset(): Unit = { _constants = null }
  // Field #4 - enums
  private[this] var _enums: scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum] = null  // Underlying type: scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum]
  override def enums: scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum] = enumsOrDefault
  override def enums_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum]): Unit = { _enums = x }
  override def enumsOption: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum]] = if (enumsIsSet) Some(_enums) else None
  override def enumsOrDefault: scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum] = if (enumsIsSet) _enums else scala.collection.immutable.Vector.empty
  override def enumsOrNull: scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum] = _enums
  override def enumsOrThrow: scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum] = if (enumsIsSet) _enums else throw new java.lang.NullPointerException("field enums of Program missing")
  override def enumsIsSet: Boolean = _enums != null
  override def enumsUnset(): Unit = { _enums = null }
  // Field #5 - typedefs
  private[this] var _typedefs: scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef] = null  // Underlying type: scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef]
  override def typedefs: scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef] = typedefsOrDefault
  override def typedefs_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef]): Unit = { _typedefs = x }
  override def typedefsOption: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef]] = if (typedefsIsSet) Some(_typedefs) else None
  override def typedefsOrDefault: scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef] = if (typedefsIsSet) _typedefs else scala.collection.immutable.Vector.empty
  override def typedefsOrNull: scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef] = _typedefs
  override def typedefsOrThrow: scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef] = if (typedefsIsSet) _typedefs else throw new java.lang.NullPointerException("field typedefs of Program missing")
  override def typedefsIsSet: Boolean = _typedefs != null
  override def typedefsUnset(): Unit = { _typedefs = null }
  // Field #6 - structs
  private[this] var _structs: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct] = null  // Underlying type: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct]
  override def structs: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct] = structsOrDefault
  override def structs_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct]): Unit = { _structs = x }
  override def structsOption: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct]] = if (structsIsSet) Some(_structs) else None
  override def structsOrDefault: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct] = if (structsIsSet) _structs else scala.collection.immutable.Vector.empty
  override def structsOrNull: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct] = _structs
  override def structsOrThrow: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct] = if (structsIsSet) _structs else throw new java.lang.NullPointerException("field structs of Program missing")
  override def structsIsSet: Boolean = _structs != null
  override def structsUnset(): Unit = { _structs = null }
  // Field #7 - unions
  private[this] var _unions: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union] = null  // Underlying type: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union]
  override def unions: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union] = unionsOrDefault
  override def unions_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union]): Unit = { _unions = x }
  override def unionsOption: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union]] = if (unionsIsSet) Some(_unions) else None
  override def unionsOrDefault: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union] = if (unionsIsSet) _unions else scala.collection.immutable.Vector.empty
  override def unionsOrNull: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union] = _unions
  override def unionsOrThrow: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union] = if (unionsIsSet) _unions else throw new java.lang.NullPointerException("field unions of Program missing")
  override def unionsIsSet: Boolean = _unions != null
  override def unionsUnset(): Unit = { _unions = null }
  // Field #8 - exceptions
  private[this] var _exceptions: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception] = null  // Underlying type: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception]
  override def exceptions: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception] = exceptionsOrDefault
  override def exceptions_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception]): Unit = { _exceptions = x }
  override def exceptionsOption: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception]] = if (exceptionsIsSet) Some(_exceptions) else None
  override def exceptionsOrDefault: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception] = if (exceptionsIsSet) _exceptions else scala.collection.immutable.Vector.empty
  override def exceptionsOrNull: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception] = _exceptions
  override def exceptionsOrThrow: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception] = if (exceptionsIsSet) _exceptions else throw new java.lang.NullPointerException("field exceptions of Program missing")
  override def exceptionsIsSet: Boolean = _exceptions != null
  override def exceptionsUnset(): Unit = { _exceptions = null }
  // Field #9 - services
  private[this] var _services: scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service] = null  // Underlying type: scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service]
  override def services: scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service] = servicesOrDefault
  override def services_=(x: scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service]): Unit = { _services = x }
  override def servicesOption: Option[scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service]] = if (servicesIsSet) Some(_services) else None
  override def servicesOrDefault: scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service] = if (servicesIsSet) _services else scala.collection.immutable.Vector.empty
  override def servicesOrNull: scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service] = _services
  override def servicesOrThrow: scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service] = if (servicesIsSet) _services else throw new java.lang.NullPointerException("field services of Program missing")
  override def servicesIsSet: Boolean = _services != null
  override def servicesUnset(): Unit = { _services = null }
  // Field #98 - typeRegistry
  private[this] var _typeRegistry: io.fsq.common.thrift.descriptors.types.gen.TypeRegistry = null  // Underlying type: io.fsq.common.thrift.descriptors.types.gen.TypeRegistry
  override def typeRegistry: io.fsq.common.thrift.descriptors.types.gen.TypeRegistry = typeRegistryOrThrow
  override def typeRegistry_=(x: io.fsq.common.thrift.descriptors.types.gen.TypeRegistry): Unit = { _typeRegistry = x }
  override def typeRegistryOption: Option[io.fsq.common.thrift.descriptors.types.gen.TypeRegistry] = if (typeRegistryIsSet) Some(_typeRegistry) else None
  override def typeRegistryOrNull: io.fsq.common.thrift.descriptors.types.gen.TypeRegistry = _typeRegistry
  override def typeRegistryOrThrow: io.fsq.common.thrift.descriptors.types.gen.TypeRegistry = if (typeRegistryIsSet) _typeRegistry else throw new java.lang.NullPointerException("field typeRegistry of Program missing")
  override def typeRegistryIsSet: Boolean = _typeRegistry != null
  override def typeRegistryUnset(): Unit = { _typeRegistry = null }
  // end fields


  private[this] var unknownFields: List[_root_.io.fsq.spindle.runtime.UnknownFields] = Nil


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    oprot.writeStructBegin(Program.PROGRAM_SDESC)
    if (namespacesIsSet) {
      oprot.writeFieldBegin(Program.NAMESPACES_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _namespaces.size))
      _namespaces.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (includesIsSet) {
      oprot.writeFieldBegin(Program.INCLUDES_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _includes.size))
      _includes.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (constantsIsSet) {
      oprot.writeFieldBegin(Program.CONSTANTS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _constants.size))
      _constants.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (enumsIsSet) {
      oprot.writeFieldBegin(Program.ENUMS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _enums.size))
      _enums.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (typedefsIsSet) {
      oprot.writeFieldBegin(Program.TYPEDEFS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _typedefs.size))
      _typedefs.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (structsIsSet) {
      oprot.writeFieldBegin(Program.STRUCTS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _structs.size))
      _structs.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (unionsIsSet) {
      oprot.writeFieldBegin(Program.UNIONS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _unions.size))
      _unions.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (exceptionsIsSet) {
      oprot.writeFieldBegin(Program.EXCEPTIONS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _exceptions.size))
      _exceptions.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (servicesIsSet) {
      oprot.writeFieldBegin(Program.SERVICES_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _services.size))
      _services.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (typeRegistryIsSet) {
      oprot.writeFieldBegin(Program.TYPEREGISTRY_FDESC)
      _typeRegistry.write(oprot)
      oprot.writeFieldEnd()
    }
  if (unknownFields.nonEmpty && io.fsq.spindle.runtime.RuntimeHelpers.preserveUnknownFields(this)) {
    unknownFields.reverse foreach { _.write(oprot) }
  }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    // Unknown fields in this read go here.
    var currentUnknownFieldsOpt: Option[_root_.io.fsq.spindle.runtime.UnknownFields] = None
    def currentUnknownFields(): _root_.io.fsq.spindle.runtime.UnknownFields = currentUnknownFieldsOpt match {
      case Some(uf) => uf
      case None => {
        val uf = new _root_.io.fsq.spindle.runtime.UnknownFields(
          this,
          _root_.io.fsq.spindle.runtime.TProtocolInfo.getProtocolName(iprot)
        )
        unknownFields = uf :: unknownFields
        currentUnknownFieldsOpt = Some(uf)
        uf
      }
    }
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Program.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // namespaces

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _namespaces = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[io.fsq.common.thrift.descriptors.headers.gen.Namespace]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = io.fsq.common.thrift.descriptors.headers.gen.Namespace.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // includes

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _includes = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[io.fsq.common.thrift.descriptors.headers.gen.Include]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = io.fsq.common.thrift.descriptors.headers.gen.Include.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 3 => {  // constants

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _constants = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[io.fsq.common.thrift.descriptors.constants.gen.Const]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = io.fsq.common.thrift.descriptors.constants.gen.Const.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 4 => {  // enums

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _enums = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[io.fsq.common.thrift.descriptors.enums.gen.Enum]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = io.fsq.common.thrift.descriptors.enums.gen.Enum.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 5 => {  // typedefs

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _typedefs = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[io.fsq.common.thrift.descriptors.types.gen.Typedef]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = io.fsq.common.thrift.descriptors.types.gen.Typedef.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 6 => {  // structs

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _structs = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[io.fsq.common.thrift.descriptors.structs.gen.Struct]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = io.fsq.common.thrift.descriptors.structs.gen.Struct.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 7 => {  // unions

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _unions = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[io.fsq.common.thrift.descriptors.structs.gen.Union]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = io.fsq.common.thrift.descriptors.structs.gen.Union.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 8 => {  // exceptions

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _exceptions = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[io.fsq.common.thrift.descriptors.structs.gen.Exception]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = io.fsq.common.thrift.descriptors.structs.gen.Exception.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 9 => {  // services

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _services = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[io.fsq.common.thrift.descriptors.services.gen.Service]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = io.fsq.common.thrift.descriptors.services.gen.Service.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 98 => {  // typeRegistry

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRUCT) {
              _typeRegistry = ({
                val s = io.fsq.common.thrift.descriptors.types.gen.TypeRegistry.createRawRecord
                s.read(iprot)
                s
              })
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => {
            if (io.fsq.spindle.runtime.RuntimeHelpers.preserveUnknownFields(this)) {
              currentUnknownFields().readUnknownField(iprot, field_header, this)  // May call this method recursively.
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Program".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
  }

  override def merge(that: Program): Unit = {
    if (that.namespacesIsSet && !this.namespacesIsSet) {
      this.namespaces_=(that.namespacesOrDefault)

    } else if (that.namespacesIsSet && this.namespacesIsSet) {
      this.namespaces_=(this.namespaces ++ that.namespaces)
    }
    if (that.includesIsSet && !this.includesIsSet) {
      this.includes_=(that.includesOrDefault)

    } else if (that.includesIsSet && this.includesIsSet) {
      this.includes_=(this.includes ++ that.includes)
    }
    if (that.constantsIsSet && !this.constantsIsSet) {
      this.constants_=(that.constantsOrDefault)

    } else if (that.constantsIsSet && this.constantsIsSet) {
      this.constants_=(this.constants ++ that.constants)
    }
    if (that.enumsIsSet && !this.enumsIsSet) {
      this.enums_=(that.enumsOrDefault)

    } else if (that.enumsIsSet && this.enumsIsSet) {
      this.enums_=(this.enums ++ that.enums)
    }
    if (that.typedefsIsSet && !this.typedefsIsSet) {
      this.typedefs_=(that.typedefsOrDefault)

    } else if (that.typedefsIsSet && this.typedefsIsSet) {
      this.typedefs_=(this.typedefs ++ that.typedefs)
    }
    if (that.structsIsSet && !this.structsIsSet) {
      this.structs_=(that.structsOrDefault)

    } else if (that.structsIsSet && this.structsIsSet) {
      this.structs_=(this.structs ++ that.structs)
    }
    if (that.unionsIsSet && !this.unionsIsSet) {
      this.unions_=(that.unionsOrDefault)

    } else if (that.unionsIsSet && this.unionsIsSet) {
      this.unions_=(this.unions ++ that.unions)
    }
    if (that.exceptionsIsSet && !this.exceptionsIsSet) {
      this.exceptions_=(that.exceptionsOrDefault)

    } else if (that.exceptionsIsSet && this.exceptionsIsSet) {
      this.exceptions_=(this.exceptions ++ that.exceptions)
    }
    if (that.servicesIsSet && !this.servicesIsSet) {
      this.services_=(that.servicesOrDefault)

    } else if (that.servicesIsSet && this.servicesIsSet) {
      this.services_=(this.services ++ that.services)
    }
    if (that.typeRegistryIsSet && !this.typeRegistryIsSet) {
      this.typeRegistry_=(that.typeRegistryOrNull)
    }
  }

  override def mergeCopy(that: Program): Program = {
    val ret = Program.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Program => this.equals(o)
    case _ => false
  }

  def equals(that: Program): Boolean = {
    that != null &&
    (if (this.namespacesIsSet) (that.namespacesIsSet && this.namespacesOrDefault == that.namespacesOrDefault) else !that.namespacesIsSet) &&
    (if (this.includesIsSet) (that.includesIsSet && this.includesOrDefault == that.includesOrDefault) else !that.includesIsSet) &&
    (if (this.constantsIsSet) (that.constantsIsSet && this.constantsOrDefault == that.constantsOrDefault) else !that.constantsIsSet) &&
    (if (this.enumsIsSet) (that.enumsIsSet && this.enumsOrDefault == that.enumsOrDefault) else !that.enumsIsSet) &&
    (if (this.typedefsIsSet) (that.typedefsIsSet && this.typedefsOrDefault == that.typedefsOrDefault) else !that.typedefsIsSet) &&
    (if (this.structsIsSet) (that.structsIsSet && this.structsOrDefault == that.structsOrDefault) else !that.structsIsSet) &&
    (if (this.unionsIsSet) (that.unionsIsSet && this.unionsOrDefault == that.unionsOrDefault) else !that.unionsIsSet) &&
    (if (this.exceptionsIsSet) (that.exceptionsIsSet && this.exceptionsOrDefault == that.exceptionsOrDefault) else !that.exceptionsIsSet) &&
    (if (this.servicesIsSet) (that.servicesIsSet && this.servicesOrDefault == that.servicesOrDefault) else !that.servicesIsSet) &&
    (if (this.typeRegistryIsSet) (that.typeRegistryIsSet && this.typeRegistryOrNull == that.typeRegistryOrNull) else !that.typeRegistryIsSet) &&
    true
  }

  override def hashCode(): Int = {
    // We use a fixed seed, for consistency.
    val hasher = new _root_.io.fsq.spindle.runtime.MurmurHash[AnyRef](0)
    if (namespacesIsSet) hasher.append(_namespaces.##)
    if (includesIsSet) hasher.append(_includes.##)
    if (constantsIsSet) hasher.append(_constants.##)
    if (enumsIsSet) hasher.append(_enums.##)
    if (typedefsIsSet) hasher.append(_typedefs.##)
    if (structsIsSet) hasher.append(_structs.##)
    if (unionsIsSet) hasher.append(_unions.##)
    if (exceptionsIsSet) hasher.append(_exceptions.##)
    if (servicesIsSet) hasher.append(_services.##)
    if (typeRegistryIsSet) hasher.append(_typeRegistry.##)
    hasher.hash
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (namespacesIsSet) ret = namespacesOrDefault :: ret
    if (includesIsSet) ret = includesOrDefault :: ret
    if (constantsIsSet) ret = constantsOrDefault :: ret
    if (enumsIsSet) ret = enumsOrDefault :: ret
    if (typedefsIsSet) ret = typedefsOrDefault :: ret
    if (structsIsSet) ret = structsOrDefault :: ret
    if (unionsIsSet) ret = unionsOrDefault :: ret
    if (exceptionsIsSet) ret = exceptionsOrDefault :: ret
    if (servicesIsSet) ret = servicesOrDefault :: ret
    if (typeRegistryIsSet) ret = typeRegistryOrNull :: ret
    ret.reverse
  }

  override def clear() {
    namespacesUnset()
    includesUnset()
    constantsUnset()
    enumsUnset()
    typedefsUnset()
    structsUnset()
    unionsUnset()
    exceptionsUnset()
    servicesUnset()
    typeRegistryUnset()
  unknownFields = Nil
  }

  def fieldForId(id: Int): Program._Fields = id match {
    case 1 => Program._Fields.namespaces
    case 2 => Program._Fields.includes
    case 3 => Program._Fields.constants
    case 4 => Program._Fields.enums
    case 5 => Program._Fields.typedefs
    case 6 => Program._Fields.structs
    case 7 => Program._Fields.unions
    case 8 => Program._Fields.exceptions
    case 9 => Program._Fields.services
    case 98 => Program._Fields.typeRegistry
    case _ => null
  }

  def isSet(field: Program._Fields): Boolean = field match {
    case Program._Fields.namespaces => namespacesIsSet
    case Program._Fields.includes => includesIsSet
    case Program._Fields.constants => constantsIsSet
    case Program._Fields.enums => enumsIsSet
    case Program._Fields.typedefs => typedefsIsSet
    case Program._Fields.structs => structsIsSet
    case Program._Fields.unions => unionsIsSet
    case Program._Fields.exceptions => exceptionsIsSet
    case Program._Fields.services => servicesIsSet
    case Program._Fields.typeRegistry => typeRegistryIsSet
    case _ => false
  }

  def getFieldValue(field: Program._Fields): AnyRef = field match {
    case Program._Fields.namespaces => namespacesOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.includes => includesOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.constants => constantsOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.enums => enumsOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.typedefs => typedefsOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.structs => structsOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.unions => unionsOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.exceptions => exceptionsOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.services => servicesOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.typeRegistry => typeRegistryOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Program._Fields, value: AnyRef) {
    field match {
      case Program._Fields.namespaces => namespaces_=(value.asInstanceOf[scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace]])
      case Program._Fields.includes => includes_=(value.asInstanceOf[scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include]])
      case Program._Fields.constants => constants_=(value.asInstanceOf[scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const]])
      case Program._Fields.enums => enums_=(value.asInstanceOf[scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum]])
      case Program._Fields.typedefs => typedefs_=(value.asInstanceOf[scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef]])
      case Program._Fields.structs => structs_=(value.asInstanceOf[scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct]])
      case Program._Fields.unions => unions_=(value.asInstanceOf[scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union]])
      case Program._Fields.exceptions => exceptions_=(value.asInstanceOf[scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception]])
      case Program._Fields.services => services_=(value.asInstanceOf[scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service]])
      case Program._Fields.typeRegistry => typeRegistry_=(value.asInstanceOf[io.fsq.common.thrift.descriptors.types.gen.TypeRegistry])
      case _ =>
    }
  }

  override def deepCopy(): RawProgram = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Program.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      namespaces: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Namespace] = namespacesOrNull,
      includes: scala.collection.Seq[io.fsq.common.thrift.descriptors.headers.gen.Include] = includesOrNull,
      constants: scala.collection.Seq[io.fsq.common.thrift.descriptors.constants.gen.Const] = constantsOrNull,
      enums: scala.collection.Seq[io.fsq.common.thrift.descriptors.enums.gen.Enum] = enumsOrNull,
      typedefs: scala.collection.Seq[io.fsq.common.thrift.descriptors.types.gen.Typedef] = typedefsOrNull,
      structs: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Struct] = structsOrNull,
      unions: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Union] = unionsOrNull,
      exceptions: scala.collection.Seq[io.fsq.common.thrift.descriptors.structs.gen.Exception] = exceptionsOrNull,
      services: scala.collection.Seq[io.fsq.common.thrift.descriptors.services.gen.Service] = servicesOrNull,
      typeRegistry: io.fsq.common.thrift.descriptors.types.gen.TypeRegistry = typeRegistryOrNull
  ): RawProgram = {
    val ret = new RawProgram
    if (namespaces != null) ret.namespaces_=(namespaces)
    if (includes != null) ret.includes_=(includes)
    if (constants != null) ret.constants_=(constants)
    if (enums != null) ret.enums_=(enums)
    if (typedefs != null) ret.typedefs_=(typedefs)
    if (structs != null) ret.structs_=(structs)
    if (unions != null) ret.unions_=(unions)
    if (exceptions != null) ret.exceptions_=(exceptions)
    if (services != null) ret.services_=(services)
    if (typeRegistry != null) ret.typeRegistry_=(typeRegistry)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val oprot = new _root_.io.fsq.spindle.common.thrift.base.TStringProtocol(trans)
    write(oprot)
    trans.toString("UTF8")
  }
}



